void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    
    float jump = 0.003;
    float xJump = 1.0 / iResolution.x;
    float yJump = 1.0 / iResolution.y;
    
    // setup
    // test UV for input image
    sCoord uv = fragCoord / iChannelResolution[0].xy;
    
    // TESTING
    // set iChannel0 to 'Misc/Buffer A' and fetch sample
    fragColor = texture(iChannel1, uv);
    
    //for 3x3
    float weights[3] = float[3](1.0,2.0,4.0);
    float weights2[6] = float[6](1.0,4.0,7.0,16.0,26.0,41.0);
    /*fragColor = (
        texture(iChannel1, vec2(uv.x - xJump, uv.y + yJump)) * weights[0] +
        texture(iChannel1, vec2(uv.x, uv.y + yJump)) * weights[1] +
        texture(iChannel1, vec2(uv.x + xJump, uv.y + yJump)) * weights[0] +
        texture(iChannel1, vec2(uv.x - xJump, uv.y)) * weights[1] +
        texture(iChannel1, uv) * weights[2] +
        texture(iChannel1, vec2(uv.x + xJump, uv.y)) * weights[1] +
        texture(iChannel1, vec2(uv.x - xJump, uv.y - yJump)) * weights[0] +
        texture(iChannel1, vec2(uv.x, uv.y - yJump)) * weights[1] +
        texture(iChannel1, vec2(uv.x + xJump, uv.y - yJump)) * weights[0]
        ) / 16.0; */
                                 
fragColor = (
        texture(iChannel1, vec2(uv.x - 2.0*xJump, uv.y + 2.0*yJump)) * weights2[0] +
		texture(iChannel1, vec2(uv.x - xJump, uv.y + 2.0*yJump)) * weights2[1] +                                 
        texture(iChannel1, vec2(uv.x, uv.y + 2.0*yJump)) * weights2[2] +
        texture(iChannel1, vec2(uv.x + xJump, uv.y + 2.0*yJump)) * weights2[1] +
        texture(iChannel1, vec2(uv.x + 2.0*xJump, uv.y + 2.0*yJump)) * weights2[0] +
        
       
        texture(iChannel1, vec2(uv.x - 2.0*xJump, uv.y + yJump)) * weights2[1] +
		texture(iChannel1, vec2(uv.x - xJump, uv.y + yJump)) * weights2[3] +                                 
        texture(iChannel1, vec2(uv.x, uv.y + yJump)) * weights2[4] +
        texture(iChannel1, vec2(uv.x + xJump, uv.y + yJump)) * weights2[3] +
        texture(iChannel1, vec2(uv.x + 2.0*xJump, uv.y + yJump)) * weights2[1] +
        
        texture(iChannel1, vec2(uv.x - 2.0*xJump, uv.y)) * weights2[2] +
		texture(iChannel1, vec2(uv.x - xJump, uv.y)) * weights2[4] +                                 
        texture(iChannel1, vec2(uv.x, uv.y)) * weights2[5] +
        texture(iChannel1, vec2(uv.x + xJump, uv.y)) * weights2[4] +
        texture(iChannel1, vec2(uv.x + 2.0*xJump, uv.y)) * weights2[2] +
        
        texture(iChannel1, vec2(uv.x - 2.0*xJump, uv.y - yJump)) * weights2[1] +
		texture(iChannel1, vec2(uv.x - xJump, uv.y - yJump)) * weights2[3] +                                 
        texture(iChannel1, vec2(uv.x, uv.y - yJump)) * weights2[4] +
        texture(iChannel1, vec2(uv.x + xJump, uv.y - yJump)) * weights2[3] +
        texture(iChannel1, vec2(uv.x + 2.0*xJump, uv.y - yJump)) * weights2[1] +
        
        texture(iChannel1, vec2(uv.x - 2.0*xJump, uv.y - 2.0*yJump)) * weights2[0] +
		texture(iChannel1, vec2(uv.x - xJump, uv.y - 2.0*yJump)) * weights2[1] +                                 
        texture(iChannel1, vec2(uv.x, uv.y - 2.0*yJump)) * weights2[2] +
        texture(iChannel1, vec2(uv.x + xJump, uv.y - 2.0*yJump)) * weights2[1] +
        texture(iChannel1, vec2(uv.x + 2.0*xJump, uv.y -2.0*yJump)) * weights2[0] 
        ) / 273.0;                                 
}