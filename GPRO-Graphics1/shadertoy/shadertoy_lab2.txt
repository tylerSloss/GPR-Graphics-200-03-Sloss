#define colorRGB	vec3
#define colorRGBA	vec4
#define texsize		vec2
#define checker_size 	float
vec4 myEffect0( in vec2 fragCoord, in vec2 resolution )
{
    //vec3 color = vec3(fragCoord,0.0);
    //vec3 color = vec3(1.0,1.0, 0.0);
    
    vec2 uv = fragCoord / resolution;
    vec3 color = colorRGB(uv, 0.0);
    float alpha = 1.0;   
    return colorRGBA(color,alpha);
    
    float myArray[2] = float[2](2.0,20.0);
}



vec4 myEffect1( in vec2 fragCoord, in vec2 resolution)
{
    //vec3 color = vec3(fragCoord,0.0);
    //vec3 color = vec3(1.0,1.0, 0.0);
    
    vec2 uv = mod(fragCoord / resolution,0.2);
    vec3 color = colorRGB(uv, 0.0);
    float alpha = 1.0; 
	return colorRGBA(color,alpha);
      
}

vec4 myEffect2(in vec2 fragCoord, in vec2 resolution)
{
  	vec2 uv = fragCoord.xy;
    vec2 uv2 = fragCoord / resolution;
    vec2 circlePos = iResolution.xy * 0.5;
    float cColor = iTime / 3.0;
    cColor = mod(cColor,3.0);
    float radius = (0.25 * iResolution.y) * cColor;
    float d = length(circlePos - uv) - radius;
	float t = clamp(d, 0.0, 1.0);
    float alpha = 1.0;
    float cInc = 0.1;
   	vec3 color1 = colorRGB(0.0,0.0,0.0);
    vec4 layer1 = colorRGBA(color1,alpha);
    vec3 color2 = 0.5 + 0.5*cos(iTime+uv2.xyx+vec3(0,2,4));
   	vec4 layer2 = colorRGBA(color2, alpha - t);
    return mix(layer1, layer2, layer2.a);
}


void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // R, G, B, A => [0,1]
    //fragColor = myEffect0(fragCoord,iResolution.xy);
    //fragColor = myEffect1(fragCoord,iResolution.xy);
    fragColor = myEffect2(fragCoord,iResolution.xy);
    
    
    // Normalized pixel coordinates (from 0 to 1)
   // vec2 uv = fragCoord/iResolution.xy;

    // Time varying pixel color
   // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));

    // Output to screen
   // fragColor = vec4(col,1.0);
}