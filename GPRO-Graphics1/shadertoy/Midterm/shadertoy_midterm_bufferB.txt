// GLSL STARTER CODE BY DANIEL S. BUCKSTEIN
//  -> BUFFER A TAB (scene)

//------------------------------------------------------------
// RENDERING FUNCTIONS

// calcColor: calculate the color of current pixel
//	  vp:  input viewport info
//	  ray: input ray info
color4 calcColor(in sViewport vp, in sRay ray)
{
    // test inputs
    //return color4(ray.direction.xyz == vp.viewportPoint.xyz); // pass
    //return color4(lengthSq(vp.viewportPoint.xy) >= 0.25); // pass
    //return color4(vp.uv, 0.0, 0.0);
    //return color4(vp.ndc, 0.0, 0.0);
    //return asPoint(sBasis(vp.viewportPoint.xy, -vp.viewportPoint.z));
    
    //SCENE
    sSphere orbit;
    initSphere(orbit, vec3(0.5 * sin(iTime * 9.0), -0.1 * cos(iTime * 9.0), -4.0 + 0.5 * cos(iTime * 9.0)), 0.05);
    sLight brightTwo;
    initLight(brightTwo, vec4(4.0 *cos(iTime), 4.0, -2.0 * sin(iTime),0.0), vec3(1.0, 1.0, 1.0), 1000.0);
    
    //TEST
    vec3 dp;
    dp.xy = ray.direction.xy - orbit.center.xy;	
    float lSq = lengthSq(dp.xy),
        rSq = orbit.radius * orbit.radius;
    //if(length(dp.xy) <= sphere.radius)
    if (lSq <= rSq)
    {
        dp.z = rSq - lSq;
        
        vec3 position = orbit.center.xyz + 
            vec3(dp.x, dp.y, sqrt(dp.z)); // zSq -> z
        
        vec3 normal = (position - orbit.center.xyz) / orbit.radius;
        
        //Blinn-Phong
        vec4 bPhong1 = vec4(blinnPhongReflectance(brightTwo, normal, position, (normal * 0.5 + 0.5), ray.direction.xyz), 1.0);
        
        
        return bPhong1;
    }
    
    
}


//------------------------------------------------------------
// SHADERTOY MAIN

// mainImage: process the current pixel (exactly one call per pixel)
//    fragColor: output final color for current pixel
//    fragCoord: input location of current pixel in image (in pixels)
void mainImage(out color4 fragColor, in sCoord fragCoord)
{
    // viewing plane (viewport) inputs
    const sBasis eyePosition = sBasis(0.0);
    const sScalar viewportHeight = 2.0, focalLength = 1.5;
    
    // viewport info
    sViewport vp;

    // ray
    sRay ray;
    
    // render
    initViewport(vp, viewportHeight, focalLength, fragCoord, iResolution.xy);
    initRayPersp(ray, eyePosition, vp.viewportPoint.xyz);
   
    
    //translate ray into cubemap points
    vec3 cubeLoc = ray.direction.xyz;
    
    //rotate ray based on iTime
    mat2 rotationMatrix = mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime));
    cubeLoc.xz = cubeLoc.xz * rotationMatrix; //rotating cubemap based on time
    vec4 layer1 = texture(iChannel1, cubeLoc);
    vec4 layer2 = calcColor(vp,ray);
    
    //fragColor += texture(iChannel1, cubeLoc);
    fragColor += mix(layer1,layer2,layer2.a);
}
