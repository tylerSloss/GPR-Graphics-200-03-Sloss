void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // ray
    vec4 rayDirection, rayOrigin;
    
    sCoord uv = fragCoord / iChannelResolution[1].xy;
    fragColor += texture(iChannel1, uv);
    
    // viewport info
    sViewport vp;

    // ray
    sRay ray;
    
    // viewing plane (viewport) inputs
    const sBasis eyePosition = sBasis(0.0);
    const sScalar viewportHeight = 2.0, focalLength = 1.5;
    
    // render
    initViewport(vp, viewportHeight, focalLength, fragCoord, iResolution.xy);
    initRayPersp(ray, eyePosition, vp.viewportPoint.xyz);
    
    sSphere sphere;
    initSphere(sphere, vec3(0.0,0.0,-4.0), 0.25);
    sLight brightOne,brightTwo,brightThree;
    initLight(brightOne, vec4(sin(iTime), cos(iTime) , -3.0,0.0), vec3(1.0, 1.0, 1.0), 10.0);
    initLight(brightTwo, vec4(cos(iTime), sin(iTime), 3.0,0.0), vec3(1.0, 1.0, 1.0), 10.0);
    initLight(brightThree, vec4(3.0,3.0, -3.0,0.0), vec3(1.0, 1.0, 1.0), 10.0);
    
    vec3 dp;
    dp.xy = ray.direction.xy - sphere.center.xy;	
    float lSq = lengthSq(dp.xy),
        rSq = sphere.radius * sphere.radius;
    
    if (lSq <= rSq)
    {
        //return vec4(1.0,0.5,0.0,1.0);
        
        //for now 'z' represents 'zSq'
        //dp.z = sphere.radius * sphere.radius
         //   - (dp.x * dp.x + dp.y * dp.y);
        dp.z = rSq - lSq;
        
        vec3 position = sphere.center.xyz + 
            vec3(dp.x, dp.y, sqrt(dp.z)); // zSq -> z
        
        vec3 normal = 			
            //normalize(position - sphere.center.xyz);
        	(position - sphere.center.xyz) / sphere.radius;
        
        //Blinn-Phong
        vec3 bPhong = blinnPhongReflectance(brightTwo, normal, position, (normal * 0.5 + 0.5), rayDirection.xyz);
        fragColor = vec4(bPhong, 1.0);
    }
}