// GLSL STARTER CODE BY DANIEL S. BUCKSTEIN
//  -> BUFFER A TAB (scene)

//------------------------------------------------------------
// RENDERING FUNCTIONS

// calcColor: calculate the color of current pixel
//	  vp:  input viewport info
//	  ray: input ray info
color4 calcColor(in sViewport vp, in sRay ray)
{
    
    vec4 myColor;
    
    vec2 m = (iMouse.xy - (iResolution.xy / 2.0)) * 4.2/iResolution.x;
    //m.y = -m.y;
    m.x = -m.x; 
    
    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));
    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));
    mat3 rot = rotY * rotX;
    
    //SCENE
    sSphere warp;
    initSphere(warp, vec3(0.0,0.0,-4.0), 0.5);
    float orbitSpeed = 3.4;
    float orbitOffset = 3.14159265358979 / 3.0;
    sSphere orbit1;
    initSphere(orbit1, vec3(0.5 * sin(iTime * orbitSpeed), -0.1 * cos(iTime * orbitSpeed), -4.0 + 0.5 * cos(iTime * orbitSpeed)), 0.05);
    sSphere orbit2;
    initSphere(orbit2, vec3(0.5 * sin(iTime * orbitSpeed + orbitOffset), -0.1 * cos(iTime * orbitSpeed + orbitOffset), -4.0 + 0.5 * cos(iTime * orbitSpeed + orbitOffset)), 0.05);
    sSphere orbit3;
    initSphere(orbit3, vec3(0.5 * sin(iTime * orbitSpeed + orbitOffset * 2.0), -0.1 * cos(iTime * orbitSpeed + orbitOffset * 2.0), -4.0 + 0.5 * cos(iTime * orbitSpeed + orbitOffset * 2.0)), 0.05);
    sSphere orbit4;
    initSphere(orbit4, vec3(0.5 * sin(iTime * orbitSpeed + orbitOffset * 4.0), -0.1 * cos(iTime * orbitSpeed + orbitOffset * 4.0), -4.0 + 0.5 * cos(iTime * orbitSpeed + orbitOffset * 4.0)), 0.05);
    sSphere orbit5;
    initSphere(orbit5, vec3(0.5 * sin(iTime * orbitSpeed + orbitOffset * 8.0), -0.1 * cos(iTime * orbitSpeed + orbitOffset * 8.0), -4.0 + 0.5 * cos(iTime * orbitSpeed + orbitOffset * 8.0)), 0.05);
    sSphere hole;
    initSphere(hole, vec3(0.0, 0.0, -4.0), 0.3);
    sLight brightTwo;
    initLight(brightTwo, vec4(4.0 , 4.0, -2.0 ,0.0), vec3(1.0, 1.0, 1.0), 1000.0);
    brightTwo.sCenter.xyz = brightTwo.sCenter.xyz * rot;
    
    
    vec3 dp;
    dp.xy = ray.direction.xy - hole.center.xy;	
    float lSq = lengthSq(dp.xy),
        rSq = hole.radius * hole.radius;
    bool inHole = false;
    
    
    if (lSq <= rSq)
    {
        myColor = vec4(0.0, 0.0, 0.0, 1.0);
        inHole = true;
    }
    
    
    dp.xy = ray.direction.xy - orbit1.center.xy;	
    lSq = lengthSq(dp.xy),
        rSq = orbit1.radius * orbit1.radius;
    float depth = orbit1.center.z;
    if (lSq <= rSq && depth >= -4.0)
    {
        return renderSphere(dp, rSq, lSq, orbit1, ray, brightTwo);
    }
    
    dp.xy = ray.direction.xy - orbit2.center.xy;	
    lSq = lengthSq(dp.xy),
        rSq = orbit2.radius * orbit2.radius;
    depth = orbit2.center.z;
    if (lSq <= rSq && depth >= -4.0)
    {
        return renderSphere(dp, rSq, lSq, orbit2, ray, brightTwo);
    }
    
    dp.xy = ray.direction.xy - orbit3.center.xy;	
    lSq = lengthSq(dp.xy),
        rSq = orbit3.radius * orbit3.radius;
    depth = orbit3.center.z;
    if (lSq <= rSq && depth >= -4.0)
    {
    renderSphere(dp, rSq, lSq, orbit3, ray, brightTwo);
    }
    
    dp.xy = ray.direction.xy - orbit4.center.xy;	
    lSq = lengthSq(dp.xy),
        rSq = orbit4.radius * orbit4.radius;
    depth = orbit4.center.z;
    if (lSq <= rSq && depth >= -4.0)
    {
        return renderSphere(dp, rSq, lSq, orbit4, ray, brightTwo);
    }
    
    dp.xy = ray.direction.xy - orbit5.center.xy;	
    lSq = lengthSq(dp.xy),
        rSq = orbit5.radius * orbit5.radius;
    depth = orbit5.center.z;
    if (lSq <= rSq && depth >= -4.0)
    {
        return renderSphere(dp, rSq, lSq, orbit5, ray, brightTwo);
    }
    
    
    if(inHole){return myColor;}
    
    //TEST
    dp.xy = ray.direction.xy - warp.center.xy;	
    lSq = lengthSq(dp.xy),
    rSq = warp.radius * warp.radius;
    
    
    if(lSq <= 1.62 * rSq)
    {
	ray.direction.xy = dp.xy * (lSq / rSq) - dp.xy * (rSq / lSq) + warp.center.xy;
    }
    
    
    dp.xy = ray.direction.xy - orbit1.center.xy;	
    lSq = lengthSq(dp.xy),
        rSq = orbit1.radius * orbit1.radius;
    depth = orbit1.center.z;
    if (lSq <= rSq && depth < -4.0)
    {
        return renderSphere(dp, rSq, lSq, orbit1, ray, brightTwo);
    }
    
    dp.xy = ray.direction.xy - orbit2.center.xy;	
    lSq = lengthSq(dp.xy),
        rSq = orbit2.radius * orbit2.radius;
    depth = orbit2.center.z;
    if (lSq <= rSq && depth < -4.0)
    {
        return renderSphere(dp, rSq, lSq, orbit2, ray, brightTwo);
    }
    
    dp.xy = ray.direction.xy - orbit3.center.xy;	
    lSq = lengthSq(dp.xy),
        rSq = orbit3.radius * orbit3.radius;
    depth = orbit3.center.z;
    if (lSq <= rSq && depth < -4.0)
    {
    renderSphere(dp, rSq, lSq, orbit3, ray, brightTwo);
    }
    
    dp.xy = ray.direction.xy - orbit4.center.xy;	
    lSq = lengthSq(dp.xy),
        rSq = orbit4.radius * orbit4.radius;
    depth = orbit4.center.z;
    if (lSq <= rSq && depth < -4.0)
    {
        return renderSphere(dp, rSq, lSq, orbit4, ray, brightTwo);
    }
    
    dp.xy = ray.direction.xy - orbit5.center.xy;	
    lSq = lengthSq(dp.xy),
        rSq = orbit5.radius * orbit5.radius;
    depth = orbit5.center.z;
    if (lSq <= rSq && depth < -4.0)
    {
        return renderSphere(dp, rSq, lSq, orbit5, ray, brightTwo);
    }
    
    
    //translate ray into cubemap points
    vec3 cubeLoc = ray.direction.xyz;
    
    //rotate ray based on iTime
    //mat2 rotationMatrix = mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime));
    //cubeLoc.xz = cubeLoc.xz * rotationMatrix; //rotating cubemap based on time    
       
    
    //cubeLoc = (rotY * rotX) * cubeLoc;
    cubeLoc = rot * cubeLoc;
    
    vec4 layer = texture(iChannel1, cubeLoc);
    
    //dp.xy = ray.direction.xy - sphere.center.xy;
    //lSq = lengthSq(dp.xy);
    
    
    //if(length(dp.xy) <= sphere.radius)
    
    return layer;
    
    
}


//------------------------------------------------------------
// SHADERTOY MAIN

// mainImage: process the current pixel (exactly one call per pixel)
//    fragColor: output final color for current pixel
//    fragCoord: input location of current pixel in image (in pixels)
void mainImage(out color4 fragColor, in sCoord fragCoord)
{
    // viewport info
    sViewport vp;

    // ray
    sRay ray;
    
    // viewing plane (viewport) inputs
    const sBasis eyePosition = sBasis(0.0);
    const sScalar viewportHeight = 2.0, focalLength = 1.5;
    
    // render
    initViewport(vp, viewportHeight, focalLength, fragCoord, iResolution.xy);
    initRayPersp(ray, eyePosition, vp.viewportPoint.xyz);
    
    vec4 layer2 = calcColor(vp,ray);
    
    //fragColor += texture(iChannel1, cubeLoc);
    fragColor += layer2;
}
