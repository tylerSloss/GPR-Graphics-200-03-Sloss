// GLSL STARTER CODE BY DANIEL S. BUCKSTEIN

//------------------------------------------------------------
// TYPE ALIASES & UTILITY FUNCTIONS

// sScalar: alias for a 1D scalar (non-vector)
#define sScalar float

// sCoord: alias for a 2D coordinate
#define sCoord vec2

// sDCoord: alias for a 2D displacement or measurement
#define sDCoord vec2

// sBasis: alias for a 3D basis vector
#define sBasis vec3

// sPoint: alias for a point/coordinate/location in space
#define sPoint vec4

// sVector: alias for a vector/displacement/change in space
#define sVector vec4


// color3: alias for a 3D vector representing RGB color
// 	(this is non-spatial so neither a point nor vector)
#define color3 vec3

// color4: alias for RGBA color, which is non-spatial
// 	(this is non-spatial so neither a point nor vector)
#define color4 vec4


// asPoint: promote a 3D vector into a 4D vector 
//	representing a point in space (w=1)
//    v: input 3D vector to be converted
sPoint asPoint(in sBasis v)
{
    return sPoint(v, 1.0);
}

// asVector: promote a 3D vector into a 4D vector 
//	representing a vector through space (w=0)
//    v: input 3D vector to be converted
sVector asVector(in sBasis v)
{
    return sVector(v, 0.0);
}


// lengthSq: calculate the squared length of a vector type
sScalar lengthSq(sDCoord x)
{
    return dot(x, x);
}
sScalar lengthSq(sBasis x)
{
    return dot(x, x);
}
sScalar lengthSq(sVector x)
{
    return dot(x, x);
}


//------------------------------------------------------------
// VIEWPORT INFO

// sViewport: info about viewport
//    viewportPoint: location on the viewing plane 
//							x = horizontal position
//							y = vertical position
//							z = plane depth (negative focal length)
//	  pixelCoord:    position of pixel in image
//							x = [0, width)	-> [left, right)
//							y = [0, height)	-> [bottom, top)
//	  resolution:    resolution of viewport
//							x = image width in pixels
//							y = image height in pixels
//    resolutionInv: resolution reciprocal
//							x = reciprocal of image width
//							y = reciprocal of image height
//	  size:       	 in-scene dimensions of viewport
//							x = viewport width in scene units
//							y = viewport height in scene units
//	  ndc: 			 normalized device coordinate
//							x = [-1, +1) -> [left, right)
//							y = [-1, +1) -> [bottom, top)
// 	  uv: 			 screen-space (UV) coordinate
//							x = [0, 1) -> [left, right)
//							y = [0, 1) -> [bottom, top)
//	  aspectRatio:   aspect ratio of viewport
//	  focalLength:   distance to viewing plane
struct sViewport
{
    sPoint viewportPoint;
	sCoord pixelCoord;
	sDCoord resolution;
	sDCoord resolutionInv;
	sDCoord size;
	sCoord ndc;
	sCoord uv;
	sScalar aspectRatio;
	sScalar focalLength;
};

// initViewport: calculate the viewing plane (viewport) coordinate
//    vp: 		      output viewport info structure
//    viewportHeight: input height of viewing plane
//    focalLength:    input distance between viewer and viewing plane
//    fragCoord:      input coordinate of current fragment (in pixels)
//    resolution:     input resolution of screen (in pixels)
void initViewport(out sViewport vp,
                  in sScalar viewportHeight, in sScalar focalLength,
                  in sCoord fragCoord, in sDCoord resolution)
{
    vp.pixelCoord = fragCoord;
    vp.resolution = resolution;
    vp.resolutionInv = 1.0 / vp.resolution;
    vp.aspectRatio = vp.resolution.x * vp.resolutionInv.y;
    vp.focalLength = focalLength;
    vp.uv = vp.pixelCoord * vp.resolutionInv;
    vp.ndc = vp.uv * 2.0 - 1.0;
    vp.size = sDCoord(vp.aspectRatio, 1.0) * viewportHeight;
    vp.viewportPoint = asPoint(sBasis(vp.ndc * vp.size * 0.5, -vp.focalLength));
}


//------------------------------------------------------------
// RAY INFO

// sRay: ray data structure
//	  origin: origin point in scene
//    direction: direction vector in scene
struct sRay
{
    sPoint origin;
    sVector direction;
};

// initRayPersp: initialize perspective ray
//    ray: 		   output ray
//    eyePosition: position of viewer in scene
//    viewport:    input viewing plane offset
void initRayPersp(out sRay ray,
             	  in sBasis eyePosition, in sBasis viewport)
{
    // ray origin relative to viewer is the origin
    // w = 1 because it represents a point; can ignore when using
    ray.origin = asPoint(eyePosition);

    // ray direction relative to origin is based on viewing plane coordinate
    // w = 0 because it represents a direction; can ignore when using
    ray.direction = asVector(viewport - eyePosition);
}

// initRayOrtho: initialize orthographic ray
//    ray: 		   output ray
//    eyePosition: position of viewer in scene
//    viewport:    input viewing plane offset
void initRayOrtho(out sRay ray,
             	  in sBasis eyePosition, in sBasis viewport)
{
    // offset eye position to point on plane at the same depth
    initRayPersp(ray, eyePosition + sBasis(viewport.xy, 0.0), viewport);
}

//student added code
//
//------------------------------------------------------------
//LIGHT INFO

//sLight: light data structure
//	  sCenter: the origin point of the light
//    sColor: the color of the light
//	  sIntensity: the intensity of the light for reflectance calculations

struct sLight{
	vec4 sCenter;
    vec3 sColor;
    float sIntensity;
};
    
//initLight: initializes a light
//	  light: output light
//	  center: the origin point of the light
//    color: the color of the light
//	  intensity: the intensity of the light for reflectance calculations
void initLight(out sLight light, in vec4 center, in vec3 color, in float intensity)
{
    light.sCenter = center;
    light.sColor = color;
    light.sIntensity = intensity;
}

//calcDiffusionCoefficient: calculates the diffuse coefficent
//	  normal: the normal of the surface at the position
//	  position: position of the currently checked point
//	  liteCent: the center of the light
vec3 calcDiffuseCoefficient(vec3 normal, vec3 position, vec3 liteCent)
{
    return (normal * normalize(liteCent - position));
}

//calcAttenuation: calculates the attenuation of a light on a surface
//	  lite: the light being calculated for
//	  normal: the normal of the surface at the position
//	  position: position of the currently checked point
float calcAttenuation(sLight lite, vec3 normal, vec3 position)
{
    float d = lengthSq(lite.sCenter.xyz - position);
    return 1.0/(1.0 + sqrt(d)/lite.sIntensity + d/(lite.sIntensity * lite.sIntensity));
}

//lambertianReflection: calculates the Lambertian Reflectance value to be multiplied by a surface color and light color
//	  lite: the light being calculated for
//	  normal: the normal of the surface at the position
//	  position: position of the currently checked point
vec3 lambertianReflection(in sLight lite, vec3 normal, vec3 position)
{
    vec3 Id = calcDiffuseCoefficient(normal, position, lite.sCenter.xyz) * calcAttenuation(lite, normal, position);
    return Id.bbb;
}




//Step 1 code: cross fade

//crossFade: uses the viewport to sample and crossfade two textures
//	  vp: image viewport
color4 crossFade(in sViewport vp)
{
   	sCoord px = vp.pixelCoord;
    
    //texture 1
    sDCoord res = iChannelResolution[0].xy;
    sCoord loc 	= px / res ;
    loc = 4.0 * loc; //zoom
    
    //texture 2
    sDCoord res2 = iChannelResolution[3].xy;
    sCoord loc2 	= px / res2 ;
    loc2 = 1.0 * loc2; //zoom
    
    //find and mix textures based on sin(iTime)
    color4 txt1 = texture(iChannel0,loc); // full rgb
    color4 txt2 = texture(iChannel3,loc2); // full rgb
    return mix(txt1,txt2,0.5 * sin(iTime) + 0.5);
}


//Step 2 code: distored image

//distort: distort an xy coord pair based on the magnitude, speed, and frequency reduction
//	  loc: location to be altered
//	  mag: magnitude of waves
//	  speed: speed of waves moving across the image
//	  reduction: reduces the frequency of waves
void distort(out vec2 loc, float mag, float speed, float reduction)
{
    loc.y += mag * sin(loc.x/reduction + iTime * speed);
}

//distortion: distort and wormhole a texture
//	  vp: image viewport
color4 distortion(in sViewport vp)
{
    //current pixel
    sCoord px = vp.pixelCoord;
    //center point
    vec2 pt = vec2(320.0,180.0);
    //starting zoom
    float zoom = 0.7;
    
    //wormhole
    float wormHoleDistance = 10000.0;
    if (lengthSq(px - pt) < wormHoleDistance)
    zoom = zoom * 10000.0 / (wormHoleDistance - lengthSq(px - pt));
    
    //scale, distort and zoom
    sDCoord res = iChannelResolution[2].xy;
    distort(px, 8.0, 16.0, 32.0);
    sCoord loc 	= px / res ;
    loc = zoom * loc; //zoom
    
    color4 txt1 = texture(iChannel2,loc); // full rgb
    return txt1;
    
}

//Step 3 code: lighting

//lighting: uses above light and reflectance code to circle a light above a texture
//	  vp: image viewport
//	  ray: ray from the camera
color4 lighting(in sViewport vp, in sRay ray)
{
   	sCoord px = vp.pixelCoord;
    
    //circling white light
    sLight lite;
    initLight(lite, vec4(400.0 + 300.0 * sin(iTime), 225.0 + 170.0 * cos(iTime), 100.0, 0), vec3(1.0, 1.0, 1.0), 10000.0);
    vec3 normal = vec3(0, 0, 1);
    
    //scale and zoom
    sDCoord res = iChannelResolution[3].xy;
    sCoord loc 	= px / res ;
    loc = 1.0 * loc; //zoom
    
    //multiply in reflectance value and light color
    return (texture(iChannel3,loc)) * color4(lambertianReflection(lite, normal, vec3(px.x, px.y, 0.0)), 0.0) * color4(lite.sColor, 0.0);
}

//Step 4 code: cubemap

//cubemap: spins and distorts a cubemap
//	  vp: image viewport
//	  ray: ray from camera
color4 cubemap(in sViewport vp, in sRay ray)
{
    //distort ray with waves
    vec3 cubeLoc = ray.direction.xyz;
    distort(cubeLoc.xy, 0.25, 1.0, 0.25);
    
    //rotate ray based on iTime
    mat2 rotationMatrix = mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime));
    cubeLoc.xz = cubeLoc.xz * rotationMatrix;
    
    return texture(iChannel1, cubeLoc);
}


//------------------------------------------------------------
// RENDERING FUNCTIONS

// calcColor: calculate the color of current pixel
//	  vp:  input viewport info
//	  ray: input ray info
color4 calcColor(in sViewport vp, in sRay ray)
{
    // test inputs
    //return color4(ray.direction.xyz == vp.viewportPoint.xyz); // pass
    //return color4(lengthSq(vp.viewportPoint.xy) >= 0.25); // pass
    //return color4(vp.uv, 0.0, 0.0);
    //return color4(vp.ndc, 0.0, 0.0);
    //return vp.viewportPoint;
    
    //const color
    //return vec4(1.0,0.0,0.0,1.0);
    
    //texture (full-screen)
    //sampler2D tex = iChannel0;
    //sCoord loc = vp.uv; // relative to display
    sCoord px = vp.pixelCoord;
    sDCoord res = iChannelResolution[0].xy;
    sCoord loc 	= px / res ;
    loc = 4.0 * loc; //zoom
    
    
    return texture(iChannel0,loc); // full rgb
   // return texture(iChannel0,loc).rrrr; //greyscale
}


//------------------------------------------------------------
// SHADERTOY MAIN

// mainImage: process the current pixel (exactly one call per pixel)
//    fragColor: output final color for current pixel
//    fragCoord: input location of current pixel in image (in pixels)
void mainImage(out color4 fragColor, in sCoord fragCoord)
{
    // viewing plane (viewport) inputs
    const sBasis eyePosition = sBasis(0.0);
    const sScalar viewportHeight = 2.0, focalLength = 1.5;
    
    // viewport info
    sViewport vp;

    // ray
    sRay ray;
    
    // render
    initViewport(vp, viewportHeight, focalLength, fragCoord, iResolution.xy);
    initRayPersp(ray, eyePosition, vp.viewportPoint.xyz);
    //fragColor += calcColor(vp, ray);
    //fragColor += crossFade(vp);
    //fragColor += distortion(vp);
	//fragColor += lighting(vp, ray);
    fragColor += cubemap(vp, ray);
}
