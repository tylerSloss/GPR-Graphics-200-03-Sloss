//static gradient screen
vec4 myEffect0(in vec2 fragCoord, in vec2 resolution)
{
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = fragCoord/resolution;

    // Pixel color
    vec3 color = colorRGB(uv, 0.0);
	
    //Fixed alpha
    float alpha = 1.0;
    
    //Final color
    return colorRGBA(color, alpha);
}   

//color changing grid squares
vec4 myEffect1(in vec2 fragCoord, in vec2 resolution)
{
    //seeds color gradient based on 1/10 y reolution scale squares
    vec2 uv = vec2( mod(fragCoord/resolution, resolution.y * 0.1) );

    //Mathematically determines whether a region should be offset scaled to 1/10  
    vec2 binaryCheck = trunc(vec2(mod(fragCoord.x, resolution.y * 0.2), mod(fragCoord.y, resolution.y * 0.2)) / vec2(resolution.y * 0.1, resolution.y * 0.1));
    vec2 binaryAns = vec2(abs(binaryCheck.x - binaryCheck.y), abs(binaryCheck.x - binaryCheck.y));
        
    // Pixel color based on time and offset based on the checker pattern
    vec2 uvTwo = (uv + (binaryAns * vec2(0.5, 0.5))) * cos(iTime+uv.xy+vec2(0,2));
    vec3 col = colorRGB(uvTwo, 0.0);
	
    //Fixed alpha
    float alpha = 1.0;
    
    //Final color
    return colorRGBA(col, alpha);
}  

//psychedelic!!
vec4 myEffect3(in vec2 fragCoord, in vec2 resolution)
{
    //seeds color gradient based on 1/10 y reolution scale squares (oscillates with time)
    vec2 uv = vec2( mod(fragCoord/resolution, resolution.y * 0.1 /* cos(iTime)*/) );

    //Mathematically determines whether a region should be offset scaled to 1/10 y resolution squares (oscillates with time)
    vec2 binaryCheck = trunc(vec2(mod(fragCoord.x, resolution.y * 0.2 * cos(iTime)), mod(fragCoord.y, resolution.y * 0.2 * cos(iTime))) / vec2(resolution.y * 0.1, resolution.y * 0.1));
    vec2 binaryAns = vec2(abs(binaryCheck.x - binaryCheck.y), abs(binaryCheck.x - binaryCheck.y));
        
    // Pixel color based on time and offset based on the checker pattern
    vec2 uvTwo = (uv + (binaryAns * vec2(0.5, 0.5))) * cos(iTime+uv.xy+vec2(0,2));
    vec3 col = colorRGB(uvTwo, 0.0);
	
    //Fixed alpha
    float alpha = 1.0;
    
    //determines the center of the circle
    float moveRad = 60.0;
    vec2 circleCore = vec2((resolution.x * 0.5) + (moveRad * cos(iTime * 8.0)), (resolution.y * 0.5) + (moveRad * sin(iTime)));
    
    //radius of the circle
    float radius = 30.0 - 10.0 * sin(2.0 * iTime);
    
    //if in moving object, alter the color
    if(radius > sqrt(pow(fragCoord.x - circleCore.x, 2.0) + pow(fragCoord.y - circleCore.y, 2.0)))
    {
   	col = colorRGB(fragCoord/resolution, 1);
        alpha = 0.5;
    }
    
    //Final color
    return colorRGBA(col, alpha);
}

vec4 myEffect4(in vec2 fragCoord, in vec2 resolution)
{
    vec2 uv = fragCoord.xy;
    vec2 uv2 = fragCoord / resolution;
    float sizeC = iTime / 3.0;  //Changes the size over time
    sizeC = cos(sizeC) + 1.0;	//using a cos wave to make it shrink and grow
    vec2 circlePos = vec2(iResolution.x * sizeC * 0.36,iResolution.y * 0.5);  //puts circle to the middle of the screen
    float radius = (0.25 * iResolution.y) * sizeC;  //radius is set so use sizeC for the size changing effect
    float d = length(circlePos - uv) - radius; // selects only the circle 
	float t = clamp(d, 0.0, 1.0);			   // to allow for layering
    float alpha = 1.0;
 	//seeds color gradient based on 1/10 y reolution scale squares
    vec2 uv3 = vec2( mod(fragCoord/resolution, resolution.y * 0.1) );

    //Mathematically determines whether a region should be offset scaled to 1/10  
    vec2 binaryCheck = trunc(vec2(mod(fragCoord.x, resolution.y * 0.2), mod(fragCoord.y, resolution.y * 0.2)) / vec2(resolution.y * 0.1, resolution.y * 0.1));
    vec2 binaryAns = vec2(abs(binaryCheck.x - binaryCheck.y), abs(binaryCheck.x - binaryCheck.y));
        
    // Pixel color based on time and offset based on the checker pattern
    vec2 uvTwo = (uv3 + (binaryAns * vec2(0.5, 0.5))) * cos(iTime+uv3.xy+vec2(0,2));
    vec3 col = colorRGB(uvTwo, 0.0);   
    
    vec4 layer1 = colorRGBA(col,alpha);
    vec3 color2 = 0.5 + 0.5*cos(iTime+uv2.xyx+vec3(0,2,4)); // color2 causes the rainbow changing effect used in the circle
   	vec4 layer2 = colorRGBA(color2, alpha - t);
    return mix(layer1, layer2, layer2.a); //finally, combine the 2 layers to have the circle overlap the background
    
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // R, G, B, A => [0,1]
    //fragColor = myEffect0(fragCoord,iResolution.xy);
    //fragColor = myEffect1(fragCoord,iResolution.xy);
    //fragColor = myEffect2(fragCoord,iResolution.xy);
    //fragColor = myEffect3(fragCoord,iResolution.xy);
    fragColor = myEffect4(fragCoord,iResolution.xy);
    
   
}